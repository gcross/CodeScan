-- @+leo-ver=4-thin
-- @+node:gcross.20081211125211.2:@thin Permutations.hs
-- @@language Haskell

module CodeQuest.CodeScan.Permutations where

-- @<< Imports >>
-- @+node:gcross.20081211125211.15:<< Imports >>
import Data.Tree
import Data.List
import Data.Array.IArray
import Control.Exception
import Debug.Trace
-- @-node:gcross.20081211125211.15:<< Imports >>
-- @nl

-- @<< Types >>
-- @+node:gcross.20081211125211.4:<< Types >>
type Permutation = Array Int Int
type PermutationNode = Tree Int
type PermutationForest = Forest Int

instance Ord a => Ord (Tree a) where
    compare x y = compare (rootLabel x) (rootLabel y)

-- @-node:gcross.20081211125211.4:<< Types >>
-- @nl

-- @+others
-- @+node:gcross.20081217102346.2:Generators -> Permutation Forest
-- @+node:gcross.20081211125211.13:computeForestFromGenerators
computeForestFromGeneratorsUsingDimino :: [Permutation] -> PermutationForest
computeForestFromGeneratorsUsingDimino [] = []
computeForestFromGeneratorsUsingDimino generators =
    -- For convenience, fetch the first generator and use it to find
    -- the size of the permutations.
    let first_generator = head generators
        size = permutationLength first_generator in
    -- Now use this size to compute the identity element.
    let identity = identityPermutation size in    
    -- Start out by computing the cyclic subgroup generated by the first generator
    let computeCyclicSubgroupElements current_subgroup_elements last_element =
            let next_element = multiplyPermutationByPermutation first_generator last_element in
            if isIdentity next_element
                then current_subgroup_elements -- we've exhausted all of the elements in this subgroup
                else computeCyclicSubgroupElements (next_element:current_subgroup_elements) next_element
        cyclic_subgroup_elements = computeCyclicSubgroupElements [identity] identity
        cyclic_subgroup_forest = mergeForests $ map permutationToForest cyclic_subgroup_elements in
    -- This next function is the iteration step.  It recursively computes a subgroup spanned
    -- by increasing numbers of generators until all generators are included and the subgroup = the desired group
    let computeSubgroup old_subgroup_forest current_generators remaining_generators =
            -- Coset representatives are processed by multiplying them by generators to see if we
            -- get new coset representatives.  When we do, we compute the coset, add it to the 
            -- forest, and then also add it to the stack of representatives we have to process.
            let processCosetRepresentatives current_forest [] = current_forest
                processCosetRepresentatives current_forest (current_representative:remaining_representatives) =
                    -- We go through each generator and see if it gives us a new coset representative.
                    let tryGenerator coset_representatives_found current_forest [] = (coset_representatives_found,current_forest)
                        tryGenerator coset_representatives_found current_forest (current_generator:remaining_generators) =
                            let coset_representative_candidate = multiplyPermutationByPermutation current_generator current_representative in
                            if (permutationContainedIn current_forest coset_representative_candidate)
                                then tryGenerator coset_representatives_found current_forest remaining_generators
                                else let coset_forest = multiplyPermutationByForest coset_representative_candidate old_subgroup_forest
                                         new_forest = merge2Forests current_forest coset_forest
                                     in tryGenerator (coset_representative_candidate:coset_representatives_found) new_forest remaining_generators
                        (new_representatives,updated_forest) = tryGenerator [] current_forest current_generators
                    in processCosetRepresentatives updated_forest (remaining_representatives ++ new_representatives)
                -- Start the iteration by processing the (trivial) coset representative: the identity.  If new representatives
                -- can be formed by multiplying the identity by generators, then these too will be processed recursively.
                updated_forest = processCosetRepresentatives old_subgroup_forest [identity]
            -- If we've gone through all the generators, then subgroup = group, so we're done.  Otherwise add another
            -- generator to the list of current_generators and compute that subgroup.
            in case remaining_generators of
                [] -> updated_forest
                next_generator:remaining_generators -> computeSubgroup updated_forest (next_generator:current_generators) remaining_generators
    in case (tail generators) of
        [] -> cyclic_subgroup_forest -- only one generator?  then we are already done!
        next_generator:remaining_generators -> computeSubgroup cyclic_subgroup_forest [first_generator,next_generator] remaining_generators
-- @-node:gcross.20081211125211.13:computeForestFromGenerators
-- @+node:gcross.20081215152235.2:computeForestFromGeneratorsNaively
computeForestFromGenerators :: [Permutation] -> PermutationForest
computeForestFromGenerators [] = []
computeForestFromGenerators generators =
    let size = permutationLength $ head generators
        accumulate old_size current_forest =
            let new_size = numberOfPermutationsInForest current_forest in
            if new_size == old_size then current_forest
                else accumulate new_size $ merge2Forests current_forest $ mergeForests $ map (\p -> multiplyPermutationByForest p current_forest) generators
    in accumulate 0 (permutationToForest $ identityPermutation size)
-- @-node:gcross.20081215152235.2:computeForestFromGeneratorsNaively
-- @-node:gcross.20081217102346.2:Generators -> Permutation Forest
-- @+node:gcross.20081217102346.3:Permutation Functions
-- @+node:gcross.20081211125211.18:cycleToPermutation
cycleToPermutation :: Int -> [Int] -> Permutation
cycleToPermutation size [] = identityPermutation size
cycleToPermutation size (x:[]) = identityPermutation size
cycleToPermutation size lst = 
    let first = (head lst)
        rest = (tail lst)
        makeAssignmentList head [] = (head,first):[]
        makeAssignmentList head (next:tail) = (head,next):(makeAssignmentList next tail)
    in (identityPermutation size) // (makeAssignmentList first rest)

cyclesToPermutation :: Int -> [[Int]] -> Permutation
cyclesToPermutation size cycles = foldr multiplyPermutationByPermutation (identityPermutation size) $  map (cycleToPermutation size) cycles
-- @-node:gcross.20081211125211.18:cycleToPermutation
-- @+node:gcross.20081211125211.17:identityPermutation
identityPermutation :: Int -> Permutation
identityPermutation 0 = listArray (0,0) []
identityPermutation size = listArray (0,size-1) [0..size-1]
-- @-node:gcross.20081211125211.17:identityPermutation
-- @+node:gcross.20081211125211.11:isIdentity
isIdentity :: Permutation -> Bool
isIdentity permutation = 
    let (min_bound,max_bound) = bounds permutation
        checkIndex :: Int -> Bool
        checkIndex index
            | index > max_bound = True
            | otherwise         = ((permutation!index) == index) && (checkIndex (index+1))
    in checkIndex min_bound
-- @-node:gcross.20081211125211.11:isIdentity
-- @+node:gcross.20081211125211.9:multiplyPermutationByPermutation
multiplyPermutationByPermutation :: Permutation -> Permutation -> Permutation
multiplyPermutationByPermutation permutation1 permutation2 = amap ((!) permutation1) permutation2
-- @nonl
-- @-node:gcross.20081211125211.9:multiplyPermutationByPermutation
-- @+node:gcross.20081211214849.4:listToPermutation
listToPermutation :: [Int] -> Permutation
listToPermutation [] = array (0,0) []
listToPermutation list = listArray (0, length(list)-1) list
-- @-node:gcross.20081211214849.4:listToPermutation
-- @+node:gcross.20081212145859.9:permutationLength
permutationLength :: Permutation -> Int
permutationLength permutation =
    let (min_bound,max_bound) = bounds permutation
    in assert (min_bound==0 && max_bound>=0) (max_bound-min_bound+1)
-- @-node:gcross.20081212145859.9:permutationLength
-- @-node:gcross.20081217102346.3:Permutation Functions
-- @+node:gcross.20081217102346.4:Forest Functions
-- @+node:gcross.20081211125211.5:addPermutationToForest
addPermutationToForest :: PermutationForest -> Permutation -> PermutationForest
addPermutationToForest forest permutation = merge2Forests forest (permutationToForest permutation)
-- @-node:gcross.20081211125211.5:addPermutationToForest
-- @+node:gcross.20081211125211.7:merge2Forests
merge2Forests :: PermutationForest -> PermutationForest -> PermutationForest
merge2Forests [] forest = forest
merge2Forests forest [] = forest
merge2Forests (tree1:forest1) (tree2:forest2) =
    case compare tree1 tree2 of
        EQ -> Node { rootLabel = rootLabel tree1, subForest = merge2Forests (subForest tree1) (subForest tree2)}:(merge2Forests forest1 forest2)
        LT -> tree1:(merge2Forests forest1 (tree2:forest2))
        GT -> tree2:(merge2Forests (tree1:forest1) forest2)
-- @-node:gcross.20081211125211.7:merge2Forests
-- @+node:gcross.20081211125211.8:mergeForests
mergeForests :: [PermutationForest] -> PermutationForest
mergeForests [] = []
mergeForests forests = foldr1 merge2Forests forests
-- @nonl
-- @-node:gcross.20081211125211.8:mergeForests
-- @+node:gcross.20081211125211.10:multiplyPermutationByForest
multiplyPermutationByForest :: Permutation -> PermutationForest -> PermutationForest
multiplyPermutationByForest permutation forest =
    let multiplyByTree Node {rootLabel=index            ,subForest=forest} 
                     = Node {rootLabel=permutation!index,subForest=multiplyPermutationByForest permutation forest} in
    sort $ map multiplyByTree forest
-- @-node:gcross.20081211125211.10:multiplyPermutationByForest
-- @+node:gcross.20081211125211.12:permutationContainedIn
permutationContainedIn :: PermutationForest -> Permutation -> Bool
permutationContainedIn forest permutation =
    let (min_bound,max_bound) = bounds permutation
        checkIndex index current_forest
            | index > max_bound = True
            | otherwise =
                case find (\node -> (rootLabel node) == (permutation!index)) current_forest of
                    Nothing -> False
                    Just node -> checkIndex (index+1) (subForest node)
    in checkIndex min_bound forest
-- @-node:gcross.20081211125211.12:permutationContainedIn
-- @+node:gcross.20081211125211.6:permutationToForest
permutationToForest :: Permutation -> PermutationForest
permutationToForest permutation =
    let buildTree indexList =
            case indexList of
                []        -> []
                head:tail -> [Node { rootLabel = head, subForest = buildTree tail }]
    in buildTree $ elems permutation
-- @-node:gcross.20081211125211.6:permutationToForest
-- @+node:gcross.20081211125211.16:pretty printing
mapForest :: (a -> b) -> Forest a -> Forest b
mapForest thunk nodes = map (mapTree thunk) nodes

mapTree :: (a -> b) -> Tree a -> Tree b
mapTree thunk (Node {rootLabel=label,subForest=forest}) = Node {rootLabel=(thunk label), subForest = (mapForest thunk forest)}

showForest :: Show a => Forest a -> Forest String
showForest = mapForest show

showTree :: Show a => Tree a -> Tree String
showTree = mapTree show
-- @nonl
-- @-node:gcross.20081211125211.16:pretty printing
-- @+node:gcross.20081212145859.2:forestToPermutationList
forestToPermutationList :: PermutationForest -> [Permutation]
forestToPermutationList [] = []
forestToPermutationList forest =
    let treeToPermutationList chain tree = 
            let new_chain = (rootLabel tree:chain) in
                  case subForest tree of
                      [] -> [listToPermutation $ reverse $ new_chain]
                      forest -> concat $ map (treeToPermutationList new_chain) forest
    in concat $ map (treeToPermutationList []) forest
-- @-node:gcross.20081212145859.2:forestToPermutationList
-- @+node:gcross.20081215152235.6:numberOfPermutationsInForest
numberOfPermutationsInForest permutations = sum $ map (length . last . levels) permutations
-- @-node:gcross.20081215152235.6:numberOfPermutationsInForest
-- @-node:gcross.20081217102346.4:Forest Functions
-- @-others

-- @<< Main >>
-- @+node:gcross.20081215152235.5:<< Main >>
-- @+at
--  main = let permutation = [array (0,1) [(0,1),(1,0)]]
--             forest1 = drawForest $ showForest $ computeForestFromGenerators 
--  permutation
--             forest2 = drawForest $ showForest $ 
--  computeForestFromGeneratorsNaively permutation
--          in do putStrLn forest1
--                putStrLn "----------------------------------"
--                putStrLn forest2
--  
-- @-at
-- @@c
-- @-node:gcross.20081215152235.5:<< Main >>
-- @nl
-- @-node:gcross.20081211125211.2:@thin Permutations.hs
-- @-leo
